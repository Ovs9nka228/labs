## Магические методы (Dunder Methods)

**Цель работы:** Научиться использовать специальные методы Python для перегрузки операторов, изменения поведения объектов при выводе, итерации и использовании в контекстных менеджерах.

**Задачи работы:**
1.  Изучить теоретический материал по Dunder методам.
2.  Реализовать классы, поддерживающие стандартные операции Python (`+`, `-`, `print`, `len`, `with`).
### Практическая часть

#### Задача 1 (Представление объектов)
Создайте класс `Book`, который принимает `title`, `author` и `year`.
Реализуйте методы:
1.  `__str__`: возвращает строку вида `"Название" (Автор, Год)`.
2.  `__repr__`: возвращает строку, с помощью которой можно пересоздать объект: `Book('Title', 'Author', 2020)`.

**Пример:**
```python
book = Book("1984", "George Orwell", 1949)
print(book)          # "1984" (George Orwell, 1949)
print(repr(book))    # Book('1984', 'George Orwell', 1949)
```

```python
class Book:
    def __init__(self, title, author, year):
        self.title = title
        self.author = author
        self.year = year
    def __str__(self):
        return f'"{self.title}" ({self.author}, {self.year})'
    def __repr__(self):
        return f'Book("{self.title}", "{self.author}", {self.year})'
book = Book("1984", "George Orwell", 1949)
print(book)
print(repr(book))
```
#### Задача 2 (Арифметика и Сравнение)
Реализуйте класс `Vector` (вектор на плоскости), который принимает координаты `x` и `y`.
Реализуйте методы:
1.  `__str__`: вид `Vector(x, y)`.
2.  `__add__`: складывает два вектора (возвращает новый объект `Vector`).
3.  `__sub__`: вычитает один вектор из другого.
4.  `__mul__`:
    *   Если умножаем на число (`int` или `float`) — умножает координаты на это число.
    *   Если умножаем на другой `Vector` — возвращает **скалярное произведение** ($x_1*x_2 + y_1*y_2$).
5.  `__eq__`: векторы равны, если равны их координаты.

**Пример:**
```python
v1 = Vector(2, 3)
v2 = Vector(4, 1)

print(v1 + v2)  # Vector(6, 4)
print(v1 - v2)  # Vector(-2, 2)
print(v1 * 3)   # Vector(6, 9)
print(v1 * v2)  # 11 (2*4 + 3*1)
print(v1 == Vector(2, 3)) # True
```

```python
class Vector:
    def __init__(self, x, y):
        self.x = x
        self.y = y
    def __str__(self):
        return f"Vector({self.x}, {self.y})"
    def __add__(self, other):
        new_x = self.x + other.x
        new_y = self.y + other.y
        return Vector(new_x, new_y)
    def __sub__(self, other):
        new_x = self.x - other.x
        new_y = self.y - other.y
        return Vector(new_x, new_y)
    def __mul__(self, other):
        if isinstance(other, (int, float)):
            new_x = self.x * other
            new_y = self.y * other
            return Vector(new_x, new_y)
        elif isinstance(other, Vector):
            result = self.x * other.x + self.y * other.y
            return result
    def __eq__(self, other):
        if isinstance(other, Vector):
            return self.x == other.x and self.y == other.y
        return False
v1 = Vector(2, 3)
v2 = Vector(4, 1)
print(v1 + v2)
print(v1 - v2)
print(v1 * 3)
print(v1 * v2)
print(v1 == Vector(2, 3))
print(v1 == v2)
```
#### Задача 3 (Вызываемые объекты)
Создайте класс `Multiplier`, который при инициализации запоминает число-множитель.
Реализуйте метод `__call__`, чтобы объект класса можно было вызывать как функцию, передавая ей число.

**Пример:**
```python
by_5 = Multiplier(5)
print(by_5(10)) # 50
print(by_5(2))  # 10
```

```python
class Multiplier:
    def __init__(self, multiplier):
        self.multiplier = multiplier
    def __call__(self, number):
        return self.multiplier * number
by_5 = Multiplier(5)
print(by_5(10))
print(by_5(2))
by_3 = Multiplier(3)
print(by_3(4))
print(by_3(7))
```
#### Задача 4 (Работа с таймером / Context Manager)
Напишите класс `Timer`, который измеряет время выполнения блока кода.
1.  `__enter__`: запоминает время начала (используйте `time.time()`).
2.  `__exit__`: считает разницу между текущим временем и началом, и выводит: `Время выполнения: X.XX сек`.

Если внутри блока `with` возникла ошибка, таймер всё равно должен вывести время, а затем выбросить ошибку дальше (для этого `__exit__` должен вернуть `None` или `False`).

**Пример:**
```python
import time

with Timer():
    time.sleep(1.5)
    # Код выполнится, и в конце увидим сообщение
```
**Вывод:**
```
Время выполнения: 1.51 сек
```

```python
import time
class Timer:
    def __enter__(self):
        self.start_time = time.time()
        return self
    def __exit__(self, exc_type, exc_value, traceback):
        end_time = time.time()
        elapsed_time = end_time - self.start_time
        print(f"Время выполнения: {elapsed_time:.2f} сек")
        return False
print("Пример 1 - нормальное выполнение:")
with Timer():
    time.sleep(1.5)
    print("  Код внутри блока выполнен")
print("\nПример 2 - быстрое выполнение:")
with Timer():
    for i in range(1000):
        pass
    print("  Цикл выполнен")
print("\nПример 3 - с ошибкой внутри:")
try:
    with Timer():
        time.sleep(0.5)
        result = 1 / 0
except ZeroDivisionError:
    print("  Ошибка была поймана после таймера")
```
#### Задача 5 (Пользовательская коллекция)
Создайте класс `SmartList`, который наследуется от встроенного `list`.
Реализуйте (переопределите) метод `__getitem__`:
*   Если индекс положительный — работает как обычно.
*   Если индекс отрицательный — возвращает элемент с начала списка (например, -1 это 0-й элемент, -2 это 1-й и т.д.). *Да, мы ломаем стандартную логику Python ради тренировки!*

**Пример:**
```python
sl = SmartList([10, 20, 30])
print(sl[0])   # 10
print(sl[-1])  # 10 (В обычном списке было бы 30)
print(sl[-2])  # 20
```

```python
class SmartList(list):
    def __getitem__(self, index):
        if index < 0:
            positive_index = abs(index) - 1
            return super().__getitem__(positive_index)
        else:
            return super().__getitem__(index)
s1 = SmartList([10, 20, 30])
print("Тестирование SmartList:")
print(f"s1 = {s1}")
print(f"s1[0] = {s1[0]}")
print(f"s1[-1] = {s1[-1]}")
print(f"s1[-2] = {s1[-2]}")
print(f"s1[-3] = {s1[-3]}")
print(f"s1[1] = {s1[1]}")
print(f"s1[2] = {s1[2]}")
s1.append(40)
print(f"\nПосле добавления 40: {s1}")
print(f"s1[-1] = {s1[-1]}")
print(f"s1[-4] = {s1[-4]}")
print("\nСравнение с обычным списком:")
normal_list = [10, 20, 30]
print(f"normal_list[-1] = {normal_list[-1]}")
print(f"s1[-1] = {s1[-1]}")
```