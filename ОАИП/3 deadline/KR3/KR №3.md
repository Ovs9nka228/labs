---
name: Контрольная работа по третьему дедлайну
tags:
  - test
  - python
  - mermaid
---
## Контрольная работа по третьему дедлайну

**Цель работы:** Выполнить контрольную работу по темам третьего дедлайна (ООП и продвинутые функции)

**Задачи работы:**
1. Написать код по заданию вашего варианта [[Варианты]]

**Критерии оценки:**
1. Правильность кода - 5 баллов
2. Использование только изученных тем (ООП, декораторы, генераторы и др.) - 1 балл
3. Оформление кода по формату PEP8, использовать аннотации типов и докстрингс - 2 балла

### Практическая часть

#### Вариант 1
Напишите программу, которая:

1. Создает класс `BankAccount` с атрибутом баланса (приватным).
2. Реализует декоратор `@audit_log`, который оборачивает методы пополнения и снятия средств. Декоратор должен печатать в консоль: «Выполнена операция "имя метода". Сумма: "аргумент"».
3. В классе должны быть реализованы методы:
	- `deposit(amount)` - пополнить баланс;
	- `withdraw(amount)` - снять деньги со счёта;
	- `balance()` - узнать баланс.
4. Создайте экземпляр класса и проведите несколько операций.

#### Вариант 2
Реализуйте систему с использованием **генераторов**:

1. Напишите функцию-генератор `fibonacci_gen(n)`, которая генерирует `n` чисел последовательности Фибоначчи.
2. Создайте класс `SequenceAnalyzer`.
3. В классе реализуйте метод, который принимает генератор, проходит по нему и возвращает список только четных чисел из сгенерированной последовательности.
4. Продемонстрируйте работу, запросив 10 чисел Фибоначчи.

#### Вариант 3
Используйте **рекурсию** и **классы**:

1. Создайте класс `FileManager`.
2. Напишите рекурсивный метод, который принимает словарь (имитирующий файловую систему, где ключи — папки, а значения — файлы или вложенные словари) и имя файла.
3. Метод должен искать файл на любой глубине вложенности и возвращать путь к нему (или `True`, если найден).
4. Оцените сложность вашего алгоритма (Big O) в комментарии к коду.

#### Вариант 4
Работа с **дандер-методами (Magic methods)**:

1. Создайте класс `Box` (Коробка), который при инициализации принимает текущий `volume` (объем) вещей в ней.
2. Реализуйте методы:
   - `__str__`: возвращает строку вида `"Коробка объемом: X"`.
   - `__add__`: позволяет сложить два объекта `Box`. Результатом должен быть **новый** объект `Box` с суммарным объемом.
   - `__mul__`: позволяет умножить коробку на целое число `n` (например, `box * 3`). Результатом должен быть новый `Box` с объемом, увеличенным в `n` раз.
   - `__eq__`: позволяет сравнивать две коробки на равенство их объемов.
3. Продемонстрируйте создание коробок, их сложение, умножение и сравнение в коде.

#### Вариант 5
Используйте **датаклассы** и **сортировку**:

1. Объявите датакласс (`@dataclass`) `Student`, содержащий поля: `name` (строка), `age` (число), `average_grade` (float).
2. Создайте список из 5 студентов с разными данными.
3. Реализуйте сортировку списка студентов по среднему баллу (`average_grade`) по убыванию, используя `lambda` функцию или метод `__lt__` внутри датакласса.
4. Выведите отсортированный список.

#### Вариант 6
Работа с паттерном **Синглтон (Singleton)** и **миксинами**:

1. Реализуйте класс `EventLogger` (Журнал событий), который должен быть Синглтоном. Он хранит в себе список событий (строк).
2. Создайте миксин `HTMLReportMixin`. Этот миксин должен добавлять класс-клиенту метод `get_html()`, который возвращает все события из списка, отформатированные как HTML-список (`<ul><li>Событие 1</li>...</ul>`).
3. Подмешайте миксин в `EventLogger` и реализуйте метод `add_event(text)`.
4. Продемонстрируйте работу:
   - Создайте `logger1`, добавьте событие «Запуск системы».
   - Создайте `logger2`, добавьте событие «Ошибка подключения».
   - Убедитесь, что список событий общий, вызвав метод `get_html()` у любого из экземпляров.

#### Вариант 7
Используйте **абстрактные классы** и **наследование**:

1. Создайте абстрактный класс `Shape` (модуль `abc`) с абстрактными методами `area()` (площадь) и `perimeter()` (периметр).
2. Реализуйте два дочерних класса: `Rectangle` (прямоугольник) и `Circle` (круг), которые наследуются от `Shape`.
3. В каждом классе реализуйте вычисление площади и периметра.
4. Создайте список фигур и в цикле выведите их площади, используя полиморфизм.

#### Вариант 8
Работа с **замыканиями** и **класс-методами**:

1. Напишите функцию `power_factory(exponent)`, которая возвращает новую функцию. Эта новая функция должна возводить переданное ей число в степень `exponent` (замыкание).
2. Создайте класс `MathTools`.
3. Реализуйте в нем `classmethod` под названием `create_power_list`, который принимает список чисел и степень `n`.
4. Внутри метода используйте замыкание из п.1, чтобы возвести все числа списка в степень `n` и вернуть новый список.

#### Вариант 9
Задача на **бесконечные генераторы** и **исключения**:

1. Напишите обычный генератор, который бесконечно возвращает случайные числа от 1 до 100.
2. Создайте класс `Processor`.
3. В классе напишите метод, который принимает этот генератор и суммирует числа.
4. Если сумма превышает 1000, метод должен вызывать исключение `StopIteration` (или просто прерывать цикл `break`) и возвращать количество потребовавшихся чисел.

#### Вариант 10
Комбинация **рекурсии** и **декораторов** (кэширование):

1. Напишите рекурсивную функцию для вычисления факториала числа `n`.
2. Напишите декоратор `@memoize`, который кэширует результаты вызовов функции (сохраняет результаты в словаре, чтобы не считать одно и то же дважды).
3. Примените декоратор к функции факториала.
4. Вызовите функцию несколько раз для одного и того же числа и докажите (через `print` внутри функции или декоратора), что повторный расчет не производится.
5. Проведите тест с помощью модуля time для проверки времени выполнения функции в первый раз и во второй раз (из кэша)