## Оценка сложности алгоритмов (Big O)

**Цель работы:** Научиться определять временную сложность алгоритмов (Big O notation), понимать разницу между эффективным и неэффективным кодом, а также научиться оптимизировать медленные алгоритмы.

**Задачи работы:**
1. Изучить теоретический материал по Big O.
2. Провести анализ сложности готовых кусков кода.
3. Доказать на практике разницу между $O(n)$, $O(n^2)$ и $O(1)$.
4. Оптимизировать "медленный" алгоритм.
### Практическая часть

#### Задача 1. Анализ кода (Теория)
Создайте файл `1.py`. Скопируйте туда код ниже и для каждой функции в комментариях укажите её сложность ($O(1)$, $O(n)$, $O(n^2)$, $O(\log n)$) и краткое пояснение, почему вы так считаете.

```python
# 1. Функция поиска
def task_1(arr):
    for i in arr:
        if i == 100:
            return True
    return False
# Сложность: O(...) - пояснение

# 2. Функция доступа
def task_2(arr):
    return arr[0] + arr[-1]
# Сложность: O(...) - пояснение

# 3. Функция пар
def task_3(arr):
    count = 0
    for i in arr:
        for j in arr:
            if i == j:
                count += 1
    return count
# Сложность: O(...) - пояснение
```

```python
# 1. Функция поиска Python
def task_1(arr):
    for i in arr:           # проходим по всем элементам массива
        if i == 100:        # проверяем каждый элемент
            return True     # если нашли 100, возвращаем True
    return False            # если не нашли, возвращаем False

# Сложность: O(n) - потому что в худшем случае нужно проверить все элементы массива

# 2. Функция доступа
def task_2(arr):
    return arr[0] + arr[-1]  # просто берем первый и последний элемент

# Сложность: O(1) - потому что мы сразу обращаемся к конкретным элементам, не проходя по всем

# 3. Функция пар
def task_3(arr):
    count = 0
    for i in arr:           # первый цикл по всем элементам
        for j in arr:       # второй цикл по всем элементам
            if i == j:      # сравниваем элементы
                count += 1  # увеличиваем счетчик
    return count

# Сложность: O(n²) - потому что для каждого элемента первого цикла 
# мы проходим все элементы второго цикла (n * n = n²)
```
#### Задача 2. Скрытая сложность Python
В Python некоторые операции выглядят простыми, но работают медленно.
Создайте файл `2.py`, в котором реализуйте сравнение скорости работы двух операций удаления элемента из списка:
1. `pop(0)` - удаление из начала списка.
2. `pop()` - удаление с конца списка.

**Алгоритм задания:**
1. Создайте список из 100 000 элементов (например, `list(range(100_000))`).
2. В цикле 1000 раз удалите элемент из начала (`pop(0)`). Замерьте время.
3. Снова создайте такой же список.
4. В цикле 1000 раз удалите элемент с конца (`pop()`). Замерьте время.
5. Выведите результаты и в комментарии напишите вывод: какая операция быстрее и почему (какова их сложность в Big O).

```python
import time
big_list = list(range(100000))
print("Измеряем время удаления из начала списка (pop(0))...")
start_time = time.time()
for i in range(1000):
    if big_list:
        big_list.pop(0)
end_time = time.time()
time_pop_0 = end_time - start_time
print(f"Время выполнения pop(0): {time_pop_0:.4f} секунд\n")
print("Измеряем время удаления с конца списка (pop())...")
big_list = list(range(100000))
start_time = time.time()
for i in range(1000):
    if big_list:
        big_list.pop()
end_time = time.time()
time_pop_end = end_time - start_time
print(f"Время выполнения pop(): {time_pop_end:.4f} секунд\n")
print("=" * 50)
print("РЕЗУЛЬТАТЫ:")
print(f"pop(0): {time_pop_0:.4f} секунд")
print(f"pop() : {time_pop_end:.4f} секунд")
if time_pop_0 > time_pop_end:
    print("\npop() работает БЫСТРЕЕ, чем pop(0)")
    print(f"Разница в {time_pop_0 / time_pop_end:.1f} раз")
else:
    print("\npop(0) работает БЫСТРЕЕ, чем pop()")
print("\n" + "=" * 50)
print("ПОЧЕМУ ТАК ПРОИСХОДИТ:")
print("1. pop() - удаление с конца: O(1)")
print("   Это быстрая операция, так как не нужно двигать другие элементы")
print("2. pop(0) - удаление из начала: O(n)")
print("   Это медленная операция, так как после удаления первого элемента")
print("   нужно сдвинуть ВСЕ остальные элементы на одну позицию влево")
print("   Чем больше список, тем дольше это занимает времени")
```
#### Задача 3. Разница между O(n) и O(n²)
Напишите скрипт `3.py`, который наглядно показывает, почему вложенные циклы - это плохо на больших данных.

1. Реализуйте функцию `find_duplicates(arr)`, которая ищет дубликаты двумя вложенными циклами ($O(n^2)$).
2. Сгенерируйте список случайных чисел длиной **5000** элементов.
3. Замерьте время выполнения функции.
4. Увеличьте размер списка в 2 раза (до **10000**). Снова замерьте время.
5. **Вопрос:** Если данные выросли в 2 раза, во сколько раз (примерно) выросло время выполнения? Ответ напишите в `print()`.

```python
import time
import random
def find_duplicates(arr):
    duplicates = []
    for i in range(len(arr)):
        for j in range(len(arr)):
            if i != j:
                if arr[i] == arr[j]:
                    if arr[i] not in duplicates:
                        duplicates.append(arr[i])
                    break
    return duplicates
print("Тест 1: Список из 5000 элементов")
print("Генерируем случайные числа...")
list_5000 = [random.randint(1, 10000) for _ in range(5000)]
print("Ищем дубликаты (это может занять некоторое время)...")
start_time = time.time()
duplicates_5000 = find_duplicates(list_5000)
end_time = time.time()
time_5000 = end_time - start_time
print(f"Найдено дубликатов: {len(duplicates_5000)}")
print(f"Время выполнения: {time_5000:.2f} секунд\n")
print("Тест 2: Список из 10000 элементов")
print("Генерируем случайные числа...")
list_10000 = [random.randint(1, 10000) for _ in range(10000)]
print("Ищем дубликаты (это займет больше времени)...")
start_time = time.time()
duplicates_10000 = find_duplicates(list_10000)
end_time = time.time()
time_10000 = end_time - start_time
print(f"Найдено дубликатов: {len(duplicates_10000)}")
print(f"Время выполнения: {time_10000:.2f} секунд\n")
print("=" * 50)
print("РЕЗУЛЬТАТЫ:")
print(f"5000 элементов: {time_5000:.2f} секунд")
print(f"10000 элементов: {time_10000:.2f} секунд")
if time_5000 > 0:
    times_slower = time_10000 / time_5000
    print(f"\nВремя увеличилось в {times_slower:.1f} раза")
    print("\nВОПРОС: Если данные выросли в 2 раза,")
    print("во сколько раз (примерно) выросло время выполнения?")
    print("\nОТВЕТ: Время выросло примерно в", end=" ")
    if 3.5 <= times_slower <= 4.5:
        print(f"{times_slower:.1f} раза (близко к 4 разам)")
        print("Это потому что у нас O(n²) сложность!")
    else:
        print(f"{times_slower:.1f} раза")
        print("Ожидалось около 4 раз для O(n²) сложности")
else:
    print("Первое измерение заняло 0 секунд, сравнить невозможно")
print("\n" + "=" * 50)
print("ПОЧЕМУ ТАК ПРОИСХОДИТ:")
print("У нас два вложенных цикла:")
print("- Внешний цикл проходит по всем n элементам")
print("- Внутренний цикл тоже проходит по всем n элементам")
print("Всего операций: n * n = n²")
print("\nЕсли n = 5000, то операций: 5000 * 5000 = 25 000 000")
print("Если n = 10000, то операций: 10000 * 10000 = 100 000 000")
print("В 4 раза больше операций при увеличении данных в 2 раза!")
```
#### Задача 4. Оптимизация (Two Sum)
В файле `4.py` дана задача: "Найти в массиве два числа, сумма которых равна заданному `target`".

У вас есть "плохое" решение через вложенные циклы ($O(n^2)$). 
Ваша задача - написать улучшенную версию `find_pair_fast`, используя `set` или `dict`, чтобы сложность стала $O(n)$.

```python
# Медленное решение (дано)
def find_pair_slow(arr, target):
    for i in range(len(arr)):
        for j in range(i + 1, len(arr)):
            if arr[i] + arr[j] == target:
                return (arr[i], arr[j])
    return None

# Ваше быстрое решение O(n)
def find_pair_fast(arr, target):
    seen = set()
    # ... ваш код ...
    pass
```

*Продемонстрируйте, что ваша функция работает быстрее на списке из 10 000 элементов.*

```python
import time
import random
def find_pair_slow(arr, target):
    for i in range(len(arr)):
        for j in range(i + 1, len(arr)):
            if arr[i] + arr[j] == target:
                return (arr[i], arr[j])
    return None
def find_pair_fast(arr, target):
    seen = set()
    for num in arr:
        needed = target - num
        if needed in seen:
            return (needed, num)
        seen.add(num)
    return None
print("Генерируем список из 10000 случайных чисел...")
numbers = [random.randint(1, 10000) for _ in range(10000)]
index1 = random.randint(0, 9999)
index2 = random.randint(0, 9999)
while index2 == index1:
    index2 = random.randint(0, 9999)
target = numbers[index1] + numbers[index2]
print(f"Ищем пару чисел, сумма которых равна {target}")
print(f"(Известно, что числа {numbers[index1]} и {numbers[index2]} в сумме дают {target})\n")
print("=" * 50)
print("Тестируем МЕДЛЕННУЮ функцию (O(n²))...")
print("Это может занять некоторое время...")
start_time = time.time()
result_slow = find_pair_slow(numbers, target)
end_time = time.time()
time_slow = end_time - start_time
print(f"Найдена пара: {result_slow}")
print(f"Проверка: {result_slow[0]} + {result_slow[1]} = {result_slow[0] + result_slow[1]}")
print(f"Время выполнения: {time_slow:.4f} секунд\n")
print("=" * 50)
print("Тестируем БЫСТРУЮ функцию (O(n))...")
start_time = time.time()
result_fast = find_pair_fast(numbers, target)
end_time = time.time()
time_fast = end_time - start_time
print(f"Найдена пара: {result_fast}")
print(f"Проверка: {result_fast[0]} + {result_fast[1]} = {result_fast[0] + result_fast[1]}")
print(f"Время выполнения: {time_fast:.4f} секунд\n")
print("=" * 50)
print("СРАВНЕНИЕ РЕЗУЛЬТАТОВ:")
print(f"Медленная функция: {time_slow:.4f} секунд")
print(f"Быстрая функция:   {time_fast:.4f} секунд")
if time_slow > 0 and time_fast > 0:
    times_faster = time_slow / time_fast
    print(f"\nБыстрая функция работает в {times_faster:.0f} раз быстрее!")
else:
    print("\nОдна из функций выполнилась слишком быстро для измерения")
print("\n" + "=" * 50)
print("ПРОВЕРКА ПРАВИЛЬНОСТИ:")
if result_slow and result_fast:
    sum_slow = result_slow[0] + result_slow[1]
    sum_fast = result_fast[0] + result_fast[1]
    print(f"Медленная функция: {result_slow[0]} + {result_slow[1]} = {sum_slow}")
    print(f"Быстрая функция:   {result_fast[0]} + {result_fast[1]} = {sum_fast}")
    if sum_slow == target and sum_fast == target:
        print("✓ Обе функции нашли правильную пару!")
    else:
        print("✗ Что-то пошло не так...")
else:
    print("Одна из функций не нашла пару")
print("\n" + "=" * 50)
print("КАК РАБОТАЕТ БЫСТРАЯ ФУНКЦИЯ:")
print("1. Создаем пустое множество 'seen'")
print("2. Для каждого числа в массиве:")
print("   - Вычисляем, какое число нам нужно: needed = target - num")
print("   - Проверяем, есть ли 'needed' уже в множестве 'seen'")
print("   - Если есть, значит мы нашли пару!")
print("   - Если нет, добавляем текущее число в 'seen'")
print("\nПример: target = 10, числа: [3, 7, 2, 8]")
print("1. Берем 3: needed = 7 (10-3), 7 нет в seen → добавляем 3")
print("2. Берем 7: needed = 3 (10-7), 3 ЕСТЬ в seen → нашли пару (3, 7)!")
print("\nПреимущество: мы проходим по массиву всего ОДИН раз!")
```
#### Задача 5. Анализ роста (Space Complexity)
Не только время важно, но и память.
В файле `5.py` создайте две функции, которые создают список квадратов чисел от 0 до N.

1. `create_list(n)`: создает обычный список и возвращает его.
2. `create_gen(n)`: создает **генератор** (используйте круглые скобки `(x**2 for ...)` или `yield`).

Сравните размер объектов в памяти, используя `sys.getsizeof()`.

```python
import sys

n = 1000000
lst = ... # вызов функции списка
gen = ... # вызов функции генератора

print(f"Размер списка: {sys.getsizeof(lst)} байт")
print(f"Размер генератора: {sys.getsizeof(gen)} байт")
```
*В комментарии напишите, какая сложность по памяти (Space Complexity) у списка (O(n) или O(1)) и у генератора.*

```python
import sys
def create_list(n):
    result = []
    for i in range(n + 1):
        square = i ** 2
        result.append(square)
    return result
def create_gen(n):
    for i in range(n + 1):
        square = i ** 2 
        yield square
def create_gen_simple(n):
    return (i ** 2 for i in range(n + 1))
print("Создаем квадраты чисел от 0 до N")
N = 1000000
print(f"N = {N}\n")
print("Создаем список квадратов...")
start_time = time.time()
my_list = create_list(N)
end_time = time.time()
print(f"Список создан за {end_time - start_time:.2f} секунд")
print(f"Первые 5 элементов списка: {my_list[:5]}")
print("\nСоздаем генератор квадратов...")
start_time = time.time()
my_gen = create_gen(N)
end_time = time.time()
print(f"Генератор создан за {end_time - start_time:.2f} секунд")
print("Извлекаем первые 5 элементов из генератора:")
first_five = []
for i, value in enumerate(my_gen):
    first_five.append(value)
    if i >= 4:
        break
print(f"Первые 5 элементов: {first_five}")
print("\n" + "=" * 50)
print("СРАВНЕНИЕ РАЗМЕРОВ В ПАМЯТИ:")
my_list = create_list(N)
my_gen = create_gen(N)
size_list = sys.getsizeof(my_list)
size_gen = sys.getsizeof(my_gen)
print(f"Размер списка: {size_list:,} байт")
print(f"Размер генератора: {size_gen:,} байт")
if size_list > size_gen:
    times_bigger = size_list / size_gen
    print(f"\nСписок занимает в {times_bigger:.0f} раз больше памяти!")
else:
    print(f"\nГенератор занимает меньше памяти")
print("\n" + "=" * 50)
print("ДЕМОНСТРАЦИЯ РАБОТЫ ГЕНЕРАТОРА:")
small_gen = create_gen(5)
print("Генератор для чисел от 0 до 5:")
print("1. Берем первый элемент:", next(small_gen))
print("2. Берем второй элемент:", next(small_gen))
print("3. Берем третий элемент:", next(small_gen))
print("Оставшиеся элементы:")
for num in small_gen:
    print(f"  {num}")
print("\n" + "=" * 50)
print("СЛОЖНОСТЬ ПО ПАМЯТИ (Space Complexity):")
print("\n1. СПИСОК: O(n)")
print("   Почему: Список хранит ВСЕ элементы сразу в памяти.")
print(f"   Для N={N} хранится {N+1} чисел.")
print("   Чем больше N, тем больше нужно памяти.")
print("\n2. ГЕНЕРАТОР: O(1)")
print("   Почему: Генератор хранит только текущий элемент и состояние.")
print("   Элементы вычисляются 'на лету' по мере необходимости.")
print("   Память не зависит от N, всегда занимает примерно одинаково.")
print("\n" + "=" * 50)
print("ВЫВОД:")
print("Для больших данных используйте генераторы,")
print("если не нужно хранить все элементы сразу в памяти!")
```