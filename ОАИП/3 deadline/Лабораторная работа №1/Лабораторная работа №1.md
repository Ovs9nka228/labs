## Функции. Замыкания и декораторы

**Цель работы:** Изучить концепцию областей видимости, понять принцип работы замыканий и научиться применять декораторы для модификации поведения функций.

**Задачи работы:**
1. Изучить теоретический материал
2. Составить алгоритмы по заданию
### Практическая часть

#### Задание 1
Напишите функцию-замыкание `create_counter`, которая возвращает функцию. Возвращаемая функция при каждом вызове должна увеличивать счётчик на 1 и возвращать текущее значение. Счётчик должен храниться в замыкании.

**Пример:**  
Ввод:
```python
counter = create_counter()
print(counter())
print(counter())
print(counter())
```
Вывод:
```
1
2
3
```

```python
def create_counter():
    count = 0
    def counter():
        nonlocal count
        count += 1
        return count
    return counter
counter = create_counter()
print(counter())
print(counter())
print(counter())
```
#### Задача 2
Напишите простой декоратор `make_bold`, который оборачивает результат работы функции в HTML-теги `<b>` и `</b>`. Примените его к функции, которая возвращает строку.

**Пример:**  
Код:
```python
@make_bold
def get_text():
    return "Hello, World!"

print(get_text())
```
Вывод:
```
<b>Hello, World!</b>
```

```python
def make_bold(func):
    def wrapper(*args, **kwargs):
        return f"<b>{func(*args, **kwargs)}</b>"
    return wrapper
@make_bold
def greet(name):
    return f"Hello, {name}!"
print(greet("World"))
```
#### Задача 3
Напишите декоратор `logger`, который перед выполнением функции выводит сообщение: "Вызов функции [имя_функции] с аргументами: [аргументы]", а после выполнения: "Результат: [результат]".
Декоратор должен работать с любым количеством аргументов.

**Пример:**  
Ввод:
```python
@logger
def add(a, b):
    return a + b

add(5, 10)
```
Вывод:
```
Вызов функции add с аргументами: (5, 10) {}
Результат: 15
```

```python
def logger(func):
    def wrapper(*args, **kwargs):
        print(f"Вызов функции {func.__name__} с аргументами: {args} {kwargs}")
        result = func(*args, **kwargs)
        print(f"Результат: {result}")
        return result
    return wrapper
@logger
def add(a, b):
    return a + b
add(5, 10)
```
#### Задача 4
Напишите декоратор `timer`, который измеряет время выполнения декорируемой функции и выводит его на экран. Используйте модуль `time`.

**Пример:**  
Ввод:
```python
@timer
def slow_func():
    # имитация долгой работы
    for _ in range(1000000): 
        pass 

slow_func()
```
Вывод:
```
Время выполнения функции slow_func: 0.0523 сек
```

```python
import time
def timer(func):
    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        execution_time = end_time - start_time
        print(f"Время выполнения функции {func.__name__}: {execution_time:.4f} сек")
        return result
    return wrapper
@timer
def slow_func():
    for _ in range(1000000):
        pass
slow_func()
```
#### Задача 5

Напишите декоратор safe_exec, который оборачивает функцию в блок try...except для обработки ошибки деления на ноль (ZeroDivisionError).

Если во время выполнения функции возникает ошибка, декоратор должен:
1. Вывести сообщение: "Ошибка: Деление на ноль!"
2. Вернуть 0 вместо падения программы.

**Пример:**  
```python
Ввод:
@safe_exec
def divide(a, b):
    return a / b

print(f"Результат 1: {divide(10, 2)}")
print(f"Результат 2: {divide(5, 0)}")
```

Вывод:
```
Результат 1: 5.0 
Ошибка: Деление на ноль!
Результат 2: 0
```

```python
def safe_exec(func):
    def wrapper(*args, **kwargs):
        try:
            result = func(*args, **kwargs)
            return result
        except ZeroDivisionError:
            print("Ошибка: Деление на ноль!")
            return 0
    return wrapper
@safe_exec
def divide(a, b):
    return a / b
print(f"Результат 1: {divide(10, 2)}")
print(f"Результат 2: {divide(5, 0)}")
```