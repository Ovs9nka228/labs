## Рекурсия и алгоритмы

**Цель работы:** Понять принципы работы рекурсии, изучить стек вызовов, научиться определять базовые случаи, освоить алгоритм "Разделяй и властвуй" и концепцию хвостовой рекурсии.

**Задачи работы:**
1. Изучить теоретический материал
2. Решить задачи, используя **только** рекурсивный подход (циклы `for`/`while` запрещены, если не указано иное)
### Практическая часть

#### Задача 1
Напишите рекурсивную функцию `power(a, n)`, которая вычисляет значение числа `a` в степени `n`. Не используйте оператор `**` или встроенную функцию `pow`.

**Пример:**  
Ввод:
```python
print(power(2, 3)) # 2 * 2 * 2
print(power(5, 0))
```
Вывод:
```
8
1
```

```python
def power(a, n):
    if n == 0:
        return 1
    if n > 0:
        return a * power(a, n - 1)
    else:
        return 1 / power(a, -n)
print(power(2, 3))
print(power(5, 0))
print(power(2, -2))
```
#### Задача 2
Напишите рекурсивную функцию `sum_digits(number)`, которая принимает целое число и возвращает сумму его цифр.

**Пример:**  
Ввод:
```python
print(sum_digits(12345))
```
Вывод:
```
15
```
*(Пояснение: 1 + 2 + 3 + 4 + 5 = 15)*

```python
def sum_digits(number):
    if number < 0:
        number = -number
    if number < 10:
        return number
    last_digit = number % 10 
    remaining_number = number // 10 
    return last_digit + sum_digits(remaining_number)
print(sum_digits(12345))
print(sum_digits(100))
print(sum_digits(9))
print(sum_digits(-123))
```
#### Задача 3 (Разделяй и властвуй)
Реализуйте алгоритм **Бинарного поиска** с помощью рекурсии. Напишите функцию `binary_search(arr, target)`, которая возвращает индекс искомого элемента `target` в отсортированном списке `arr`. Если элемент не найден, вернуть `-1`.

*Алгоритм:*
1. Найти середину отрезка.
2. Если середина равна `target` - вернуть индекс.
3. Если `target` меньше середины - рекурсивно искать в левой половине.
4. Если `target` больше середины - рекурсивно искать в правой половине.

**Пример:**  
Ввод:
```python
my_list = [10, 20, 30, 40, 50, 60, 70]
print(binary_search(my_list, 40)
print(binary_search(my_list, 99)
```
Вывод:
```
3
-1
```

```python
def binary_search(arr, target):
    def search_helper(left, right):
        if left > right:
            return -1
        mid = (left + right) // 2
        if arr[mid] == target:
            return mid
        elif target < arr[mid]:
            return search_helper(left, mid - 1)
        else:
            return search_helper(mid + 1, right)
    return search_helper(0, len(arr) - 1)
my_list = [10, 20, 30, 40, 50, 60, 70]
print(binary_search(my_list, 40))
print(binary_search(my_list, 20))
print(binary_search(my_list, 70))
print(binary_search(my_list, 10))
print(binary_search(my_list, 99))
```
#### Задача 4 (Разделяй и властвуй)
Напишите функцию `find_max(arr)`, которая находит максимальный элемент в списке, используя принцип **"Разделяй и властвуй"**.
*Алгоритм:*
1. Если в списке 1 элемент - он и есть максимальный (базовый случай).
2. Разделите список на две части (левую и правую).
3. Рекурсивно найдите максимум в левой части и максимум в правой части.
4. Верните большее из двух полученных чисел.

**Пример:**  
Ввод:
```python
numbers = [3, 7, 1, 9, 4, 2]
print(find_max(numbers))
```
Вывод:
```
9
```

```python
def find_max(arr):
    if len(arr) == 0:
        return None 
    if len(arr) == 1:
        return arr[0]
    mid = len(arr) // 2 
    left_half = arr[:mid]
    right_half = arr[mid:]
    max_left = find_max(left_half)
    max_right = find_max(right_half)
    if max_left > max_right:
        return max_left
    else:
        return max_right
numbers = [3, 7, 1, 9, 4, 2]
print(find_max(numbers))
print(find_max([5]))
print(find_max([8, 3]))
print(find_max([1, 2, 3]))
print(find_max([10, 5, 8, 12]))
print(find_max([]))
```
#### Задача 5 (Сравнение производительности)
Это задание состоит из двух частей:
1.  Напишите обычную рекурсивную функцию `fibonacci(n)` (без оптимизаций).
2.  Напишите функцию с хвостовой рекурсией `tail_fibonacci(n, accumulator=1)`.
3.  Сравните время выполнения обеих функций для $n = 35$ с помощью модуля `time`.

*Код для проверки:*
```python
import time

n = 35

# Замер обычной рекурсии
start_time = time.time()
print(f"Fibonacci({n}) = {fibonacci(n)}")
print(f"Time taken (Naive): {time.time() - start_time:.6f} seconds")

# Замер хвостовой рекурсии
start_time = time.time()
print(f"Tail Fibonacci({n}) = {tail_fibonacci(n)}")
print(f"Time taken (Tail): {time.time() - start_time:.6f} seconds")
```

**Ожидаемый результат:** Функция с хвостовой рекурсией должна отработать мгновенно (< 0.0001 сек), тогда как обычная рекурсия может занять несколько секунд.

```python
import time
def fibonacci(n):
    if n == 0:
        return 0
    elif n == 1:
        return 1
    return fibonacci(n - 1) + fibonacci(n - 2)
def tail_fibonacci(n, a=0, b=1):
    """
    a и b - это "накопители" (аккумуляторы):
    a = F(n-2), b = F(n-1), где F - число Фибоначчи
    """
    if n == 0:
        return a
    elif n == 1:
        return b
    return tail_fibonacci(n - 1, b, a + b)
n = 35
print("=== Сравнение производительности ===")
print(f"Вычисляем Fibonacci({n})")
print()
start_time = time.time()
result1 = fibonacci(n)
time1 = time.time() - start_time
print(f"Fibonacci({n}) = {result1}")
print(f"Время выполнения (обычная рекурсия): {time1:.6f} секунд")
print()
start_time = time.time()
result2 = tail_fibonacci(n)
time2 = time.time() - start_time
print(f"Tail Fibonacci({n}) = {result2}")
print(f"Время выполнения (хвостовая рекурсия): {time2:.6f} секунд")
print()
if result1 == result2:
    print("✓ Обе функции дали одинаковый результат")
else:
    print("✗ Результаты различаются!")
print(f"\nХвостовая рекурсия быстрее в {time1/time2:.0f} раз!")
```