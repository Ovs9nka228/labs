## Проектирование классов и основы ООП

**Цель работы:** Научиться анализировать предметную область, выделять сущности (классы) и устанавливать между ними правильные связи (наследование, композиция, агрегация) с помощью инструмента **Mermaid**.

**Задачи работы:**
1. Изучить теоретический материал по проектированию.
2. Проанализировать текстовые описания задач.
3. Составить диаграммы классов (Class Diagrams) для каждой задачи.
### Практическая часть

#### Задание 1. Базовая структура (Умный дом)
Спроектируйте класс `SmartLight` (Умная лампочка).

Прибор должен иметь следующие характеристики:
**Атрибуты:**
*   `brightness` (яркость, целое число) — доступно всем.
*   `color` (цвет, строка) — доступно всем.
*   `is_on` (включена ли, булево) — скрытое (приватное) свойство, чтобы нельзя было включить "в обход" выключателя.

**Методы:**
*   `turn_on()` — включить.
*   `turn_off()` — выключить.
*   `set_color(new_color)` — изменить цвет.

```python
class SmartLight:
    brightness = 50
    color = "белый"
    def __init__(self):
        self.__is_on = False
    def turn_on(self):
        """Включить лампочку"""
        self.__is_on = True
        print("Лампочка включена")
    def turn_off(self):
        """Выключить лампочку"""
        self.__is_on = False
        print("Лампочка выключена")
    def set_color(self, new_color):
        """Изменить цвет лампочки"""
        self.color = new_color
        print(f"Цвет изменен на: {new_color}")
    def check_status(self):
        """Проверить статус лампочки"""
        if self.__is_on:
            return "Лампочка включена"
        else:
            return "Лампочка выключена"
if __name__ == "__main__":
    my_lamp = SmartLight()
    print("Доступные атрибуты:")
    print(f"Яркость: {my_lamp.brightness}")
    print(f"Цвет: {my_lamp.color}")
    my_lamp.turn_on()
    print(my_lamp.check_status())
    my_lamp.set_color("красный")
    print(f"Новый цвет: {my_lamp.color}")
    my_lamp.turn_off()
    print(my_lamp.check_status())
```
#### Задание 2. Инкапсуляция и Безопасность (Банковская карта)
Спроектируйте класс `CreditCard`.

Банковская сфера требует защиты данных, поэтому:
*   Номер карты (`number`) и CVC-код (`cvc`) должны быть **приватными** (`-`).
*   Имя владельца (`owner_name`) может быть **публичным** (`+`).
*   Баланс (`balance`) должен быть **защищенным** (`#`) (доступен классу и его наследникам, но не всем подряд).

Добавьте методы:
*   `pay(amount)` — публичный метод оплаты.
*   `check_pin(pin)` — приватный метод проверки пин-кода (вызывается внутри метода оплаты).

```python
class CreditCard:
    owner_name = "Иван Иванов"
    _balance = 1000.0
    def __init__(self, card_number, cvc_code, pin_code):
        self.__number = card_number
        self.__cvc = cvc_code
        self.__pin = pin_code
        print(f"Карта создана для владельца: {self.owner_name}")
    def __check_pin(self, pin_to_check):
        """Проверить ПИН-код"""
        if self.__pin == pin_to_check:
            return True
        else:
            return False
    def pay(self, amount, pin_code):
        """Оплатить покупку"""
        print(f"Попытка оплаты на сумму: {amount} руб.")
        if self.__check_pin(pin_code):
            if amount <= self._balance:
                self._balance -= amount
                print(f"Оплата успешна! С карты списано: {amount} руб.")
                print(f"Остаток на карте: {self._balance} руб.")
                return True
            else:
                print("Недостаточно средств на карте!")
                return False
        else:
            print("Неверный ПИН-код! Оплата отменена.")
            return False
    def show_info(self):
        """Показать информацию о карте"""
        print(f"Владелец: {self.owner_name}")
        print(f"Баланс: {self._balance} руб.")
        if hasattr(self, '_CreditCard__number'):
            masked_number = "**** **** **** " + self.__number[-4:]
            print(f"Номер карты: {masked_number}")
    def check_balance(self):
        """Проверить баланс"""
        return self._balance
if __name__ == "__main__":
    print("=== Банковская карта ===")
    my_card = CreditCard(
        card_number="1234567812345678",
        cvc_code="123",
        pin_code="0000"
    )
    print("\nИнформация о карте:")
    my_card.show_info()
    print("\n--- Попытка оплаты с правильным ПИН-кодом ---")
    my_card.pay(500, "0000")
    print("\n--- Попытка оплаты с неправильным ПИН-кодом ---")
    my_card.pay(200, "1111")
    print("\n--- Попытка оплаты суммы больше баланса ---")
    my_card.pay(800, "0000")
    print(f"\nТекущий баланс: {my_card.check_balance()} руб.")
    print(f"\nДоступ к защищенному атрибуту: {my_card._balance} руб.")
    print(f"Владелец карты: {my_card.owner_name}")
```
#### Задание 3. Наследование (Иерархия RPG)
В компьютерной игре есть разные типы персонажей:
1.  Есть базовый класс `Character` (Персонаж). У него есть имя (`name`) и метод `move()` (идти).
2.  Есть `Archer` (Лучник). Он является персонажем. У него есть дополнительный метод `shoot()` (стрелять).
3.  Есть `Knight` (Рыцарь). Он является персонажем. У него есть дополнительный метод `attack_sword()` (бить мечом).

```python
class Character:
    def __init__(self, name):
        self.name = name
        print(f"Создан персонаж: {self.name}")
    def move(self):
        """Метод для перемещения персонажа"""
        print(f"{self.name} идет вперед")
class Archer(Character):
    def __init__(self, name):
        Character.__init__(self, name)
        print(f"{self.name} - это Лучник")
    def shoot(self):
        """Метод для стрельбы из лука"""
        print(f"{self.name} стреляет из лука!")
class Knight(Character):
    def __init__(self, name):
        Character.__init__(self, name)
        print(f"{self.name} - это Рыцарь")
    def attack_sword(self):
        """Метод для атаки мечом"""
        print(f"{self.name} бьет мечом!")
if __name__ == "__main__":
    print("=== Демонстрация RPG-персонажей ===\n")
    print("1. Создаем базового персонажа:")
    hero = Character("Герой")
    hero.move()
    print("\n" + "="*50 + "\n")
    print("2. Создаем Лучника:")
    legolas = Archer("Леголас")
    legolas.move() 
    legolas.shoot()
    print("\n" + "="*50 + "\n")
    print("3. Создаем Рыцаря:")
    lancelot = Knight("Ланселот")
    lancelot.move()
    lancelot.attack_sword()
    print("\n" + "="*50 + "\n")
    print("4. Все персонажи могут двигаться:")
    characters = [
        Character("Путник"),
        Archer("Робин Гуд"),
        Knight("Король Артур")
    ]
    for char in characters:
        char.move()
        if isinstance(char, Archer):
            char.shoot()
        elif isinstance(char, Knight):
            char.attack_sword()
        print()
    print("\n" + "="*50 + "\n")
    print("5. Еще один пример Лучника:")
    elf = Archer("Эльф")
    elf.move()
    elf.shoot()
    print(f"\nЭльф является персонажем? {isinstance(elf, Character)}")
    print(f"Эльф является лучником? {isinstance(elf, Archer)}")
    print(f"Эльф является рыцарем? {isinstance(elf, Knight)}")
```
#### Задание 4. Типы связей (Музыкальный плеер)
Спроектируйте систему из двух классов: `Playlist` (Плейлист) и `Song` (Песня):
*   Класс `Song` имеет название (`title`) и длительность (`duration`).
*   Класс `Playlist` имеет название (`name`) и список песен.

```python
class Song:
    def __init__(self, title, duration):
        self.title = title
        self.duration = duration
        print(f"Создана песня: '{self.title}' ({self.duration} секунд)")
    def get_info(self):
        """Получить информацию о песне"""
        minutes = self.duration // 60
        seconds = self.duration % 60
        return f"'{self.title}' - {minutes}:{seconds:02d}"
class Playlist:
    def __init__(self, name):
        self.name = name
        self.songs = []
        print(f"Создан плейлист: '{self.name}'")
    def add_song(self, song):
        """Добавить песню в плейлист"""
        self.songs.append(song)
        print(f"Песня '{song.title}' добавлена в плейлист '{self.name}'")
    def remove_song(self, song_title):
        """Удалить песню из плейлиста по названию"""
        for song in self.songs:
            if song.title == song_title:
                self.songs.remove(song)
                print(f"Песня '{song_title}' удалена из плейлиста '{self.name}'")
                return True
        print(f"Песня '{song_title}' не найдена в плейлисте '{self.name}'")
        return False
    def show_playlist(self):
        """Показать все песни в плейлисте"""
        print(f"\n=== Плейлист: '{self.name}' ===")
        if len(self.songs) == 0:
            print("Плейлист пуст")
        else:
            total_duration = 0
            for i, song in enumerate(self.songs, 1):
                song_info = song.get_info()
                print(f"{i}. {song_info}")
                total_duration += song.duration
            total_minutes = total_duration // 60
            total_seconds = total_duration % 60
            print(f"\nВсего песен: {len(self.songs)}")
            print(f"Общая длительность: {total_minutes}:{total_seconds:02d}")
    def get_total_duration(self):
        """Получить общую длительность плейлиста"""
        total = 0
        for song in self.songs:
            total += song.duration
        return total
    def find_song(self, title):
        """Найти песню по названию"""
        for song in self.songs:
            if song.title == title:
                return song
        return None
if __name__ == "__main__":
    print("=== МУЗЫКАЛЬНЫЙ ПЛЕЕР ===\n")
    print("1. Создаем песни:")
    song1 = Song("Bohemian Rhapsody", 354)
    song2 = Song("Imagine", 183)
    song3 = Song("Hotel California", 391)
    song4 = Song("Yesterday", 125)
    print("\n" + "="*50 + "\n")
    print("2. Создаем плейлист:")
    my_playlist = Playlist("Мой любимые песни")
    print("\n" + "="*50 + "\n")
    print("3. Добавляем песни в плейлист:")
    my_playlist.add_song(song1)
    my_playlist.add_song(song2)
    my_playlist.add_song(song3)
    print("\n" + "="*50 + "\n")
    print("4. Содержимое плейлиста:")
    my_playlist.show_playlist()
    print("\n" + "="*50 + "\n")
    print("5. Добавляем еще одну песню:")
    my_playlist.add_song(song4)
    print("\n" + "="*50 + "\n")
    print("6. Обновленный плейлист:")
    my_playlist.show_playlist()
    print("\n" + "="*50 + "\n")
    print("7. Ищем песню:")
    found_song = my_playlist.find_song("Imagine")
    if found_song:
        print(f"Найдена песня: {found_song.get_info()}")
    else:
        print("Песня не найдена")
    print("\n" + "="*50 + "\n")
    print("8. Удаляем песню:")
    my_playlist.remove_song("Hotel California")
    print("\n" + "="*50 + "\n")
    print("9. Итоговый плейлист:")
    my_playlist.show_playlist()
    print("\n" + "="*50 + "\n")
    print("10. Создаем второй плейлист:")
    rock_playlist = Playlist("Рок-хиты")
    song5 = Song("Stairway to Heaven", 482)
    song6 = Song("Smoke on the Water", 340)
    rock_playlist.add_song(song5)
    rock_playlist.add_song(song6)
    rock_playlist.add_song(song1) 
    print("\n" + "="*50 + "\n")
    print("11. Второй плейлист:")
    rock_playlist.show_playlist()
```
#### Задание 5. Комплексная система (Служба доставки)
Проанализируйте текст и спроектируйте полную схему классов.

> В системе есть **Заказ**. Каждый заказ обязательно состоит из нескольких **Товаров**. Товар не может существовать в контексте заказа без самого заказа, но у товара есть название и цена.
> У заказа есть статус.
> 
> Существуют разные виды доставки: **Курьер** и **Дрон**. И Курьер, и Дрон являются **Доставщиками**. У любого Доставщика есть скорость, но только Дрон умеет летать, а Курьер умеет звонить клиенту.
> 
> Заказ закрепляется за одним конкретным Доставщиком

**Алгоритм действий:**
1.  Выделите 5 классов.
2.  Определите, где Наследование (`<|--`).
3.  Определите, где Композиция (`*--`).
4.  Определите, где Агрегация (`o--`).

```python
class Product:
    def __init__(self, name, price):
        self.name = name
        self.price = price
        print(f"Создан товар: '{self.name}' - {price} руб.")
    def get_info(self):
        """Получить информацию о товаре"""
        return f"Товар: {self.name}, Цена: {self.price} руб."
class DeliveryPerson:
    def __init__(self, speed):
        self.speed = speed
        print(f"Создан доставщик со скоростью {speed} км/ч")
    def deliver(self):
        """Метод доставки"""
        print(f"Доставщик едет со скоростью {self.speed} км/ч")
class Courier(DeliveryPerson):
    def __init__(self, name, speed, phone):
        DeliveryPerson.__init__(self, speed)
        self.name = name
        self.phone = phone
        print(f"Курьер '{self.name}' создан. Телефон: {self.phone}")
    def call_client(self):
        """Курьер умеет звонить клиенту"""
        print(f"Курьер {self.name} звонит клиенту по телефону {self.phone}")
    def deliver(self):
        """Метод доставки для курьера"""
        print(f"Курьер {self.name} доставляет заказ на мотоцикле со скоростью {self.speed} км/ч")
class Drone(DeliveryPerson):
    def __init__(self, model, speed, max_height):
        DeliveryPerson.__init__(self, speed)
        self.model = model
        self.max_height = max_height
        print(f"Дрон '{self.model}' создан. Макс. высота: {max_height} м")
    def fly(self):
        """Дрон умеет летать"""
        print(f"Дрон {self.model} летит на высоте {self.max_height} м")
    def deliver(self):
        """Метод доставки для дрона"""
        print(f"Дрон {self.model} доставляет заказ по воздуху со скоростью {self.speed} км/ч")
class Order:
    STATUSES = ["создан", "в обработке", "доставляется", "доставлен", "отменен"]
    def __init__(self, order_id):
        self.order_id = order_id
        self.status = "создан"
        self.products = []
        self.delivery_person = None
        print(f"Создан заказ #{order_id}")
    def add_product(self, name, price):
        """Добавить товар в заказ"""
        product = Product(name, price)
        self.products.append(product)
        print(f"Товар '{name}' добавлен в заказ #{self.order_id}")
    def set_delivery_person(self, delivery_person):
        """Назначить доставщика для заказа"""
        self.delivery_person = delivery_person
        print(f"Доставщик назначен для заказа #{self.order_id}")
    def change_status(self, new_status):
        """Изменить статус заказа"""
        if new_status in self.STATUSES:
            old_status = self.status
            self.status = new_status
            print(f"Статус заказа #{self.order_id} изменен: {old_status} -> {new_status}")
        else:
            print(f"Ошибка: статус '{new_status}' не существует")
    def calculate_total(self):
        """Рассчитать общую стоимость заказа"""
        total = 0
        for product in self.products:
            total += product.price
        return total
    def process_delivery(self):
        """Обработать доставку заказа"""
        if self.delivery_person is None:
            print(f"Ошибка: для заказа #{self.order_id} не назначен доставщик!")
            return
        print(f"\nНачинаем доставку заказа #{self.order_id}")
        print(f"Статус: {self.status}")
        print(f"Количество товаров: {len(self.products)}")
        print(f"Общая стоимость: {self.calculate_total()} руб.")
        self.delivery_person.deliver()
        if isinstance(self.delivery_person, Courier):
            self.delivery_person.call_client()
        elif isinstance(self.delivery_person, Drone):
            self.delivery_person.fly()
        print(f"Заказ #{self.order_id} доставлен!")
        self.change_status("доставлен")
    def show_order_info(self):
        """Показать информацию о заказе"""
        print(f"\n=== Заказ #{self.order_id} ===")
        print(f"Статус: {self.status}")
        print("Товары в заказе:")
        if len(self.products) == 0:
            print("  Нет товаров")
        else:
            for i, product in enumerate(self.products, 1):
                print(f"  {i}. {product.get_info()}")
        
        print(f"Всего товаров: {len(self.products)}")
        print(f"Общая сумма: {self.calculate_total()} руб.")
        
        if self.delivery_person:
            if isinstance(self.delivery_person, Courier):
                print(f"Доставщик: Курьер {self.delivery_person.name}")
            elif isinstance(self.delivery_person, Drone):
                print(f"Доставщик: Дрон {self.delivery_person.model}")
        else:
            print("Доставщик: не назначен")
if __name__ == "__main__":
    print("=== СЛУЖБА ДОСТАВКИ ===\n")
    print("1. Создаем доставщиков:")
    courier1 = Courier("Иван", 40, "+7-999-123-45-67")
    courier2 = Courier("Петр", 35, "+7-999-987-65-43")
    drone1 = Drone("DJI Mavic", 60, 120)
    drone2 = Drone("SkyMaster X1", 80, 200)
    print("\n" + "="*50 + "\n")
    print("2. Создаем заказ 1 (доставка курьером):")
    order1 = Order(1001)
    order1.add_product("Ноутбук", 50000)
    order1.add_product("Мышь", 1500)
    order1.add_product("Чехол", 1000)
    order1.set_delivery_person(courier1)
    order1.change_status("в обработке")
    order1.change_status("доставляется")
    order1.show_order_info()
    order1.process_delivery()
    print("\n" + "="*50 + "\n")
    print("3. Создаем заказ 2 (доставка дроном):")
    order2 = Order(1002)
    order2.add_product("Смартфон", 30000)
    order2.add_product("Наушники", 5000)
    order2.set_delivery_person(drone1)
    order2.change_status("в обработке")
    order2.change_status("доставляется")
    order2.show_order_info()
    order2.process_delivery()
    print("\n" + "="*50 + "\n")
    print("4. Создаем заказ 3 (без доставщика):")
    order3 = Order(1003)
    order3.add_product("Книга", 500)
    order3.add_product("Ручка", 50)
    order3.show_order_info()
    print("\nПытаемся обработать доставку без доставщика:")
    order3.process_delivery()
    print("\n" + "="*50 + "\n")
    print("5. Один доставщик может доставлять несколько заказов:")
    order4 = Order(1004)
    order4.add_product("Цветы", 2000)
    order4.set_delivery_person(courier1)
    order4.change_status("доставляется")
    print(f"\nКурьер {courier1.name} доставляет заказы #{order1.order_id} и #{order4.order_id}")
    print("\n" + "="*50 + "\n")
    print("6. Демонстрация наследования:")
    print(f"courier1 является DeliveryPerson? {isinstance(courier1, DeliveryPerson)}")
    print(f"drone1 является DeliveryPerson? {isinstance(drone1, DeliveryPerson)}")
    print(f"courier1 является Courier? {isinstance(courier1, Courier)}")
    print(f"drone1 является Drone? {isinstance(drone1, Drone)}")
```
#### Задание 6
Придумайте и спроектируйте структуру классов для **Социальной сети**.
В системе должны быть:
*   Пользователь.
*   Пост (сообщение).
*   Комментарий.

**Условия связей:**
1.  Один Пользователь может написать много Постов.
2.  Пост жестко привязан к Пользователю (или нет? Решите сами и обоснуйте выбором стрелки).
3.  К Посту можно оставлять Комментарии. Если удалить Пост, комментарии тоже должны исчезнуть.

**Требование:** Нарисовать схему и добавить короткий комментарий почему вы выбрали именно такие связи.

```python
import datetime
class User:
    def __init__(self, user_id, username, email):
        self.user_id = user_id
        self.username = username
        self.email = email
        self.posts = []
        self.registration_date = datetime.datetime.now()
        print(f"Создан пользователь: {self.username} (ID: {self.user_id})")
    def create_post(self, content):
        """Создать новый пост"""
        post = Post(content, self)
        self.posts.append(post)
        return post
    def get_user_info(self):
        """Получить информацию о пользователе"""
        return f"Пользователь: {self.username}\nEmail: {self.email}\nЗарегистрирован: {self.registration_date.strftime('%d.%m.%Y %H:%M')}\nПостов: {len(self.posts)}"
    def show_all_posts(self):
        """Показать все посты пользователя"""
        print(f"\n=== Все посты пользователя {self.username} ===")
        if len(self.posts) == 0:
            print("У пользователя пока нет постов")
        else:
            for post in self.posts:
                print(f"\n{post.get_post_info()}")
class Post:
    def __init__(self, content, author):
        self.content = content
        self.author = author
        self.created_at = datetime.datetime.now()
        self.comments = []
        print(f"Создан новый пост от {author.username}")
    def add_comment(self, user, comment_text):
        """Добавить комментарий к посту"""
        comment = Comment(comment_text, user, self)
        self.comments.append(comment)
        return comment
    def delete_post(self):
        """Удалить пост (вместе с комментариями)"""
        print(f"Удаляем пост и все комментарии к нему")
        if self in self.author.posts:
            self.author.posts.remove(self)
        return True
    def get_post_info(self):
        """Получить информацию о посте"""
        info = f"Пост от: {self.author.username}\n"
        info += f"Дата: {self.created_at.strftime('%d.%m.%Y %H:%M')}\n"
        info += f"Содержимое: {self.content}\n"
        info += f"Комментариев: {len(self.comments)}"
        if len(self.comments) > 0:
            info += "\nКомментарии:"
            for i, comment in enumerate(self.comments, 1):
                info += f"\n  {i}. {comment.get_comment_info()}"
        return info
    def show_comments(self):
        """Показать все комментарии к посту"""
        print(f"\n=== Комментарии к посту ===")
        print(f"Пост: '{self.content[:50]}...'")
        if len(self.comments) == 0:
            print("Пока нет комментариев")
        else:
            for comment in self.comments:
                print(f"\n{comment.get_comment_info()}")
class Comment:
    def __init__(self, text, author, post):
        self.text = text
        self.author = author
        self.post = post
        self.created_at = datetime.datetime.now()
        print(f"Добавлен комментарий от {author.username}")
    def get_comment_info(self):
        """Получить информацию о комментарии"""
        return f"{self.author.username}: {self.text}\n   ({self.created_at.strftime('%d.%m.%Y %H:%M')})"
if __name__ == "__main__":
    print("=== СОЦИАЛЬНАЯ СЕТЬ ===\n")
    print("1. Создаем пользователей:")
    user1 = User(1, "Анна", "anna@example.com")
    user2 = User(2, "Борис", "boris@example.com")
    user3 = User(3, "Виктор", "viktor@example.com")
    print("\n" + "="*50 + "\n")
    print("2. Пользователь 1 создает пост:")
    post1 = user1.create_post("Привет всем! Сегодня отличный день для прогулки в парке!")
    print("\n" + "="*50 + "\n")
    print("3. Другие пользователи комментируют пост:")
    comment1 = post1.add_comment(user2, "Согласен! Погода просто замечательная!")
    comment2 = post1.add_comment(user3, "Я только что вернулся из парка - там красиво!")
    comment3 = post1.add_comment(user1, "Спасибо за комментарии! Присоединяйтесь!")
    print("\n" + "="*50 + "\n")
    print("4. Информация о посте:")
    print(post1.get_post_info())
    print("\n" + "="*50 + "\n")
    print("5. Пользователь 2 создает свой пост:")
    post2 = user2.create_post("Кто смотрел новый фильм? Поделитесь впечатлениями!")
    post2.add_comment(user1, "Я смотрел! Очень понравилось!")
    post2.add_comment(user3, "Еще не видел, но собираюсь в выходные")
    print("\n" + "="*50 + "\n")
    print("6. Все посты пользователя Анна:")
    user1.show_all_posts()
    print("\n" + "="*50 + "\n")
    print("7. Все посты пользователя Борис:")
    user2.show_all_posts()
    print("\n" + "="*50 + "\n")
    print("8. Удаляем пост 1:")
    post1.delete_post()
    print("\n" + "="*50 + "\n")
    print("9. Проверяем посты пользователя 1 после удаления:")
    user1.show_all_posts()
    print("\n" + "="*50 + "\n")
    print("10. Создаем еще один пост:")
    post3 = user3.create_post("Рекомендую книгу 'Мастер и Маргарита' - шедевр!")
    post3.add_comment(user1, "Одна из моих любимых книг!")
    post3.add_comment(user2, "Читал в школе, нужно перечитать")
    print("\n" + "="*50 + "\n")
    print("11. Информация о посте 3:")
    print(post3.get_post_info())
    print("\n" + "="*50 + "\n")
    print("12. Демонстрация связей между объектами:")
    test_comment = post3.comments[0]
    print(f"Комментарий: '{test_comment.text}'")
    print(f"Автор комментария: {test_comment.author.username}")
    print(f"Пост комментария: '{test_comment.post.content[:30]}...'")
    print("\n" + "="*50 + "\n")
    print("13. Информация о пользователях:")
    print(user1.get_user_info())
    print()
    print(user2.get_user_info())
    print()
    print(user3.get_user_info())
```